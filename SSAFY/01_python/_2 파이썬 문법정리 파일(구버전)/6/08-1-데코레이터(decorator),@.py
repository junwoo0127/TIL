def deco(func):
    def wrapper():      # 와퍼 함수(내부함수, 클로저) 생성
        print(func.__name__, '함수 시작')   # __name__ 속성으로 함수의 이름을 가져올 수 있다.
        func()
        print(func.__name__, '함수 종료')
    return wrapper      # 와퍼 함수(클로저)를 반환


def hey():
    print('hey!')


def hello():
    print('hello~!')


trace_hey = deco(hey)   # deco 함수를 호출해서 반환받은 와퍼(wrapper) 함수를 변수에 저장
trace_hey()     # 변수에 담긴 와퍼 함수를 호출
deco(hello)()   # 걍 이렇게 한줄로도 해도 됨.
""" 데코레이터(decorator):
데코레이터(= 장식자)는 장식하다, 꾸미다라는 뜻의 decorate(데코레이트)에 or를 붙인 말로, 장식하는 도구라는 뜻이다.
말 뜻대로 함수(메쏘드)들을 장식하는 것이며, 클래스에서 정적메쏘드, 클래스메쏘드, 가상(추상)메쏘드를 만들 때
@로 시작하는 키워드를 붙였던 것이 데코레이터에 해당된다.

이런 데코레이터는 함수를 수정하지 않은 상태에서 추가 기능을 구현할 때 사용할 수 있다.
만약 똑같이 추가할 기능이 있는 함수가 1개라면, 걍 그 함수 코드안에서 기능을 추가하면 되지만,
여러개의 함수에 똑같은 기능을 추가하고 싶으면, 데코레이터가 유용하다.

데코레이터의 구조는 위같이 데코레이터 함수에 클로저(내부함수)를 만들어 데코레이터 함수가 '클로저'를 반환하는 구조로,
인자값으로 기능을 추가할 함수를 전달받아서 데코레이터에서 함수를 호출하고, 추가할 기능도 같이 실행하게 된다.

데코레이터 함수를 사용하려면 함수 바깥에서는,

데코레이터함수(데코레이트될함수)()
아니면,
변수 = 데코레이터함수(데코레이트될함수)
변수()
와 같이 해서 데코레이터 함수를 원하는 함수에 적용해서 사용할 수 있다.
"""
@deco
def haha():
    print('hahaha-!')


haha()
""" @:
이보다 더 간편하게 데코레이터를 사용할 수 있는데, 
데코레이터를 사용할 함수를 정의할 때, 그 위에다

@데코레이터이름
def 함수이름():
    코드
    
와 같이 해준다면, 
함수 바깥에서 데코레이터를 호출할 때

함수이름()
같이 호출해줘도, 데코레이터를 사용할 수 있다.
"""


def frist_deco(f):
    def wra():
        print("다른 데코레이터도 실행!")
        f()
        print("다른 데코레이터도 종료!")
    return wra


@frist_deco
@deco
def haehae():
    print('hae~hae~!')


haehae()
"""
함수에 데코레이터를 여러 개도 지정할 수 있다. 
이럴 때는 데코레이터가 위에서 아래 순으로, 가장 위의 데코레이터가 가장 바깥을 감싸고, 가장 아래의 데코레이터가 가장 안을 감싼다.
(다시말해 데코레이터가 실행되는 순서가 위에서 아래 순이다.)

@를 안쓴다면 아래 코드와 동작이 같다.
변수 = 위에선언한_데코레이터(아래에선언한_데코레이터(데코레이터될_함수))
변수()
"""
# 데코레이터는 보통 프로그램 프로그램의 버그를 찾는 디버깅, 함수의 성능 측정, 함수 실행전 데이터 확인 등에 활용.
# 함수의 시작과 끝, 매개변수, 반환값등을 데코레이터로 함수의 기능을 건들이지 않고 출력할 수 있기에 디버깅에 활용.
