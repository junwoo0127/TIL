print([1, 2, 3].__iter__())     # 리스트 뿐만 아니라,

print((1, 2, 3).__iter__())     # 튜플(tuple),
print({1, 2, 3}.__iter__())     # 집합(set),
print('123'.__iter__())     # 문자열(str),
print({1: '1', 2: '2', 3: '3'}.__iter__())     # 딕셔너리(dict),
print(range(1, 4).__iter__())    # range() 함수도 이터레이터(반복자)로 만들 수 있음.

"""
이터레이터(iterator = 반복자) 는 값을 차례대로 꺼낼 수 있는 객체임.
반복가능한 객체(iterable) 에서 얻어내며, 

반복가능한객체(군집자료형) 안에 있는 메쏘드 __iter__() 를 이용해서 이터레이터를 가져올 수 있음.
( dir(객체) 와 같이하면, 객체의 메쏘드, 속성들을 반환하는데, 거기에 __iter__ 메쏘드가 있으면 반복가능한 객체임.)

이터레이터를 변수에 저장한 뒤에, __next__() 메쏘드를 호출해서 요소들을 차례대로 꺼낼 수 있음.
요소를 하나씩 차례대로 꺼내다가 마지막 요소까지 꺼내고, 더이상 꺼낼 요소가 없는데 __next__() 메쏘드를 호출하면, 

StopIteration 예외를 발생시키며 반복을 끝냄,
"""

temp_iter = [1, 2, 3].__iter__()
print(temp_iter.__next__())
print(temp_iter.__next__())
print(temp_iter.__next__())
# print(temp_iter.__next__())     # StopIteration 예외 발생(더이상 꺼낼 요소가 없음)
"""
반복가능한 객체와 이터레이터(반복자)는 분리되어 (둘은 별개의 객체) 있지만, 
__iter__ 메쏘드로 반복가능한 객체의 이터레이터를 얻고,
__next__ 메쏘드로 이터레이터를 반복할 수 있기에 
이 두 메쏘드(__iter__, __next__)를 가진 객체를, 이터레이터 프로토콜 (iterator protocol)을 지원한다고 말함.

(for 변수 in 반복가능한 객체: 
도 사실 반복가능한 객체를 이터레이터로 만들어서, (__iter__ 메쏘드 실행)
for 문이 반복할 때마다, 이터레이터에서 차례대로 요소를 꺼내서 (__next__ 메쏘드 실행) for 문의 변수에 저장하는 것임.)
 
추가로 이터레이터에서의 값들은 양이 적을 땐 몰라도 많을 때는 미리 만들면 메모리 성능에 불리하기에,
이터레이터만 생성후, 값이 필요할 시점에 값을 만드는 방식으로 돌아감, 
이런 방식을 지연 평가(lazy evaluation = 느긋한 계산법 = 게으른 연산)이라고 함.

이것으로 규모가 큰 값을 다룰때 효율적으로 메모리를 사용할수 있고, 성능도 개선할 수 있음.
"""
