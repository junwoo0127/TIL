def coroutine_():
    while True:
        x = (yield)
        print(x)


c = coroutine_()
next(c)
c.send(1)
c.send(10)
""" 코루틴(coroutine):
COoperative ROUTINE 의 약자 코루틴의 뜻은 서로 협력하는 루틴이라는 의미다.

원래의 함수는 함수를 호출한 뒤에는 함수가 종료되면서 함수의 변수, 계산식등은 모두 사라지게 되는데,
함수를 호출하는 스크립트(메인 루틴, main routine) 상에서 함수(서브 루틴, sub routine)을 호출하면,
잠시 메인루틴은 대기하고, 그동안 서브루틴이 동작한 뒤, 동작이 끝나면 종료되면서 다시 메인루틴으로 실행이 복귀하는,
마치 메인루틴(스크립트)이 서브루틴(함수)을 잠시 도구로 사용하는 종속된 관계였다.

하지만 코루틴은 이런 종속된 관계가 아닌, 협력하는 루틴이란 이름답게 대등한 관계이며,
스크립트와 함수 모두 같은 위치로, 특정시점에 실행이 다른 루틴으로 오고 가는 방식이다.


따라서 일반함수는 호출할 때 코드는 한번만 실행되고, 종료되면서 원래 값들은 날라가지만,
코루틴은 함수가 종료되지 않은 상태에서 메인루틴(스크립트)로 실행이 넘어가며,
이때 코루틴이 종료되지 않기에 내용도 계속 유지된다.

그래서 일반함수와 달리 코루틴은 코드를 여러 번 실행할 수 있고, 이때 함수를 실행하는 지점을 진입점(entry point)
이라고 한다. (일반함수는 진입점이 1개, 코루틴은 여러개이다.)
"""


def hi_corotine():
    while True:     # 보통 코루틴은 실행 상태를 유지하기 위해 무한 루프를 사용
        print((yield))


cr = hi_corotine()
cr.__next__()
cr.send(1)
cr.send(2)
cr.send(3)
# 미리 스포하자면 코루틴도 제너레이터다. (__next__ 메쏘드와 그 수행과정이 코루틴도 제너레이터 처럼 진행된다.)
"""
제너레이터에서 사용한 yield 를 코루틴에서 사용해서 바깥에서 값을 받아올 수 있다.

변수 = (yield) 과 같으며, 반대로 함수(코루틴) 바깥에서는,

코루틴객체.send(값) 형식으로 코루틴에 값들을 보낼 수 있다.

원래 함수가 진행될때 yield 를 만나면 실행을 함수 바깥으로 양보했는데, 
이를 이용해 코루틴 함수를 최초로 실행할때는 yield 가 있는 위치까지 다다를수 있게 __next__(next()내장함수도 가능)를 사용해야 된다.

그렇게 코루틴의 yield 위치에서 메인루틴으로 실행을 양보했을 때, 코루틴객체.send(값)으로 실행을 다시 코루틴으로 넘긴다. 
이때 send() 의 인자값이 전달되서 함수의 (yield) 로 도착한다. 이것을 코루틴 안에서 원하는 대로 사용할 수 있다.

그렇게 코루틴안의 모든 코드가 끝나면 다시 메인루틴으로 넘어가고, 메인루틴에서 또 send()함수가 붙으면,
다시 코루틴으로 값이 (yield) 에 전달되서 다시 코루틴의 코드가 실행되게 된다.


참고로 코루틴의 코드를 최초로 실행할 때 next() 함수, __next__() 메쏘드로 했지만,

코루틴객체.send(None)
과 같이 해도 같은 역할을 수행한다.
"""
# 이러한 코루틴은 함수가 종료되지 않는 상태서 값을 주고 받을 수 있기에,
# 어떤 코드의 실행을 대기하고 다른 코드로 넘어가서 코드를 실행하고 이것을 왔다 갔다 할 수 있다.
# 이런 중요한 특징으로써,

# 시간이 오래 걸리는 작업을 분할 처리하거나, 파일 처리, 네트워크 처리등에 활용된다.
