def cocoroutine():
    out = 0
    while True:
        x = (yield out)
        out += x


co = cocoroutine()
print(next(co))
print(co.send(1))
print(co.send(1))
print(co.send(1))
"""
코루틴 안으로 값을 전달받았듯이 반대로 코루틴 바깥으로 값을 전달할 수 있다.

(yield 변수)
형식으로 한다면, yield 뒤의 변수가 코루틴(함수) 바깥으로 실행이 전환될 때 값도 전달된다.

next(코루틴객체)     # == 코루틴객체.__next__()
코루틴객체.send(값)
같이 코루틴 바깥에서 코루틴을 호출하면, 다시 코루틴에서 바깥으로 반환하면서, 반환값으로 아까의 변수 값이 딸려나온다.

이렇게 코루틴 안과 밖으로 실행을 왔다 갔다 하면서, 그 사이에 값을 전달받고 전달할 수 있다.

코루틴 바깥에서 코루틴을 실행할 때 __next__ 와 send 의 차이점은,
__next__ 는 코루틴으로 값을 보내지 않으면서 코루틴의 코드를 실행할 때 사용하고,
send 는 코루틴으로 값을 보내면서 코루틴의 코드를 실행할 때 사용한다.

그리고 __next__ 만 사용하게 된다면, 일반적인 제너레이터가 되게 된다.


*** 제너레이터 vs 코루틴
제너레이터는 __next__ 를 반복 호출해 값을 차례대로 뽑아내는 방식
코루틴은 __next__ 에 추가로 send 를 사용해 값을 주고받는 방식
(사실은 코루틴도 제너레이터의 일부로, 코루틴은 제너레이터에서 확장된 것이다. 
이터레이터에서 제너레이터가 나왔고, 그 제너레티어에서 코루틴도 나왔다는 것...)
"""
