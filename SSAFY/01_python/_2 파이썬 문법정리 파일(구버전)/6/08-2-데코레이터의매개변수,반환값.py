def good_deco(func):
    def wrapper(a, b):
        r = func(a, b)
        print(f'{func.__name__}함수 > {a} + {b} = {r}')
        return r
    return wrapper

@good_deco
def add(n, m):
    return n + m


print(add(10, 20))
""" 매개변수, 반환값이 있는 함수의 데코레이터 :
매개변수와 반환값이 있는 함수의 데코레이터를 만들 때는, 
데코레이터의 대상함수의 매개변수를 내부함수(wrapper)에서 똑같이 전달받아서,
대상함수를 호출할 때 매개변수를 동일하게 전달해서 호출한다.
그리고 함수를 호출할 때 전달받은 반환값을 변수에 저장해서, 내부함수(wrapper)의 반환값으로 사용한다.

이렇게 하면, 매개변수와 반환값이 있는 함수의 데코레이터를 사용할 수 있다.

마찬가지로 매개변수가 가변인수, 딕셔너리(키워드)가변인수 일경우에도 
데코레이터의 내부함수(wrapper)의 매개변수도 똑같이 해주면 된다.


데코레이터의 대상이 되는 함수가 매개변수가 있으면 내부함수에서도 그와 똑같은 매개변수를 전달 받아야 하는데,
함수중에서 클래스에서 사용되는 메쏘드도 마찬가지다. (메쏘드에서 필수로 붙는 self, cls 를 주의해야 한다.)
 
인스턴스 메쏘드는 항상 self 를 매개변수로 받기에, 데코레이터에서도 내부함수에서 첫번째 매개변수를 self 으로 지정해야 한다. 
반대로 클래스 메소드는 대신 cls 를 매개변수로 받으니, 데코레이터도 첫번째 매개변수로 cls 를 지정해야 한다.
"""


def bring_num(x):
    def real_deco(func):
        def warpper(a, b):
            r = func(a, b)
            print((str(r) + '입니다.  ') * x, func.__name__)
            return r
        return warpper
    return real_deco


@bring_num(3)
def add(a, b):
    return a + b


print(add(1, 2))
print(add(2, 3))
""" 매개변수가 있는 데코레이터 :
대상 함수의 매개변수가 아니라, 데코레이터에서의 매개변수가 있는 데코레이터도 만들 수 있다.
이때는 함수를 하나 더 만들어서,
첫번째(외부) 함수 : 에서 데코레이터에서 사용하는 매개변수를 이 함수에서 지정하고,
두번째(중간) 함수 : 에서 데코레이터의 대상 함수를 매개변수로 받아오고,
세번째(내부) 함수 : 에서 데코레이터의 대상 함수의 매개변수들을 매개변수로 받아오고, 
내부함수에서 대상 함수를 호출하고 기능도 덧붙이고, 대상함수의 반환값을 내부함수가 반환한다음.
중간 함수가 내부함수 자체를 반환하고, 그다음 외부함수가 중간함수 자체를 반환하는 구조가 추가된다.

이렇게 하면, 대상 함수 위에 
@데코레이터(인자값) 
으로 데코레이터를 사용하면서 데코레이터에 인자값도 전달 해서 사용할 수 있다.

@를 사용하지 않는다면
데코레이터(데코레이터의매개변수)(대상함수)
같은 형식으로 데코레이터를 사용하면 된다.
"""
@bring_num(2)   # 마찬가지로 먼저 사용한 데코레이터가 함수호출을 기준으로 외부를 감싸고
@bring_num(3)   # 나중에 사용한 데코레이터가 내부를 감싼다.
def minus(a, b):
    return a - b


print(minus(3, 1))  # == bring_num(2)(bring_num(3)(minus))(3, 1)    (@없이 쓸경우)
# 데코레이터안에서 함수 호출뒤에 출력문을 추가했기에 3번 출력(내부 데코)후에 2번 출력이(외부 데코)되고,
# 마지막으로 함수의 반환값이 스크립트의 print() 문으로 출력이 된다.
"""
그리고 이런 매개변수가 있는 데코레이터도 위처럼 여러 개 지정할 수 있다.
"""
from functools import wraps


def bring_num2(x):
    def real_deco2(func):
        @wraps(func)
        def warpper2(a, b):
            r = func(a, b)
            print((str(r) + '입니다.  ') * x, func.__name__)
            return r
        return warpper2
    return real_deco2


@bring_num2(5)
@bring_num2(1)
def gob(a, b):
    return a * b


print(gob(2, 2))
"""
함수에서 데코레이터를 여러개 겹쳐서 사용하면 첫번째 데코레이터에선 대상 함수의 이름이 나오지만,
두번째 데코레이터의 이름으로 다시 대상 함수의 이름이 나오지 않고, 두번째 데코레이터의 내부함수 이름이 나온다.

원래 함수의 정보가 유지 되지 않은 것인데, 이럴 때 functools 모듈의 wraps 함수를 데코레이터로해서 내부함수에 지정하고,
wraps 데코레이터에 인자값으로 원래(대상) 함수의 이름을 전달해주면,

@wraps 데코레이터가 원래 함수의 정보를 유지시켜주기에 둘다 대상 함수의 이름을 출력하게 할 수 있다.
이렇게 원래 함수의 정보를 유지시켜 주는 것은 디버깅에 유용하기에 데코레이터를 만들때 사용하는 것이 좋다.
"""