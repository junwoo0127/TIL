class deco:
    def __init__(self, func):
        self.func = func    # 대상 함수가 인스턴스 속성으로 저장되기에, 나중에 접근할때 self. 를 붙여야된다.

    def __call__(self):
        print(self.func.__name__, '함수 시작')
        self.func()
        print(self.func.__name__, '함수 끝')

@deco
def hi():
    print("hi 함수 동작!")


hi()
""" 데코레이터 클래스로 구현 :
클래스로 데코레이터를 만들 수 있는데, 인스턴스를 함수처럼 호출하게 해주는 __call__ 스페셜 메서드를 활용함.

__init__ 메서드에서 인스턴스(데코레이터)를 생성하면, 전달받은 함수를 인스턴스 속성에 저장하고,
__call__ 메서드로 인스턴스(데코레이터)가 호출된다면, 전달받은 함수를 호출하고, 추가기능도 작성함.
이때 대상 함수는 self.~ 꼴로 인스턴스 속성으로 저장했기 때문에, 호출하거나 사용할 때도, self.~ 형식을 지켜야 함.

(@를 쓰지않으면, 아래처럼 함수로 데코레이터를 호출하면 됨.)
deco(hi)()

매개변수, 반환값이 있는 함수의 데코레이터를 클래스를 구현할 때는,
__call__ 의 매개변수로 대상 함수의 매개변수와 똑같이 전달받아, 대상 함수를 호출할 때 그대로 전달해 주면 되고,
반환값은 __call__ 함수의 반환값으로 대상함수의 반환값을 반환하면 된다. (이부분은 함수로 구현했을 때와 동일하다.)
"""


class kaka:
    def __init__(self, x):  # 데코레이터의 매개변수가 있는 경우면, __init__ 에 대상함수 대신 매개변수를 전달 받는다.
        self.x = x

    def __call__(self, func):   # __call__에서 대상함수를 전달받고, 안에 내부함수(클로저)를 만든다.
        def warpper(a, b):      # 내부함수에선 대상함수의 매개변수를 전달받고, 대상함수를 호출, 반환값을 반환한다.
            r = func(a, b)
            print("결과 : ", str(r) * self.x)
            return r
        return warpper
# __call__ 함수만 보면 데코레이터를 함수로 구현했던 구조와 비슷하다. (클로저를 사용)


@kaka(3)
def add(a, b):
    return a + b


print(add(1, 2))
print(add(2, 3))
""" 매개변수가 있는 데코레이터를 클래스로 구현 :
대신 매개변수가 있는 데코레이터를 클래스로 구현할때는 다르다.

@데코레이터(인수)
와 같이 데코레이터를 사용하면서 바로 인자를 넘겨주기에, __init__ 에서 데코레이터의 매개변수를 전달 받고,
대신에 데코레이터의 대상 함수는 __call__ 에서 매개변수로 전달받는다. 
그리고 __call__ 메서드 안에 내부함수(wrapper, 클로저)로 대상함수의 매개변수를 전달받고,
내부함수 안에서 대상함수를 호출하고, 코드를 덧붙이고, 대상함수의 반환값을 내부함수가 반환한다.
그리고, __call__ 메서드에서 내부 함수 자체를 반환하면 된다.
"""