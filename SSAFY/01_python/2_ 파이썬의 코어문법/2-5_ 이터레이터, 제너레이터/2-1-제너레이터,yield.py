def hi_generator():
    yield '우'
    yield '하'
    yield '하'


for i in hi_generator():
    print(i)
""" 제너레이터(generator):
제너레이터는 이터레이터를 생성하는 함수로, yield 키워드만 사용해서 이터레이터를 생성 할 수 있다.
(제너레이터를 발생자라고도 한다.)

함수 코드블럭 안에서 yield 를 사용한다면, 그 함수는 제너레이터가 된다. (yield 값)
"""
# 제너레이터는 왜 쓸까? 이유는 이터레이터와 비슷하다.

# 리스트 처럼 리스트에 속한 모든 데이터를 한번에 데이터에 적재하지 않고, 차례대로 값을 접근할 때마다 메모리에 적재하기에
# '메모리를 효율적으로 사용할 수 있으며,' (사용하는 사이즈가 클수록 제너레이터의 효율성이 더욱 높아진다.)

# 이터레이터 처럼 lazy evaluation(게으른 연산, 느긋한 연산법)을 수행하기에,
# 리스트 같이 한번에 모두 값을 로딩해서 부담이 있지만, 제너레이터는 for 문이 수행될 때마다 그때 그때 로딩하기에,
# '성능을 개선하고, 효율적으로 코드를 작성할 수 있다.' (수행기간이 긴 연산을 필요한 순간까지 늦출 수 있다.)

save_genr = hi_generator()
print(save_genr)
print(dir(save_genr))
"""
제너레이터 함수를 호출하면 제너레이터 객체가 반환되며, 그 객체를 dir() 함수의 인자값으로 넘겨서,
이터레이터에 있는 __iter__, __next__ 메쏘드가 반환되는 걸 볼 수 있다. (제너레이터 객체가 이터레이터임을 알 수 있다.)

더이상 출력할 것이 없으면, StopIteration 에러가 이터레이터 처럼 나오고, for 문에 들어가도 실행되는 과정이 이터레이터 그대로다.
(대신 이터레이터에서 return 으로 직접 __next__ 했을 때 값을 반환했지만, 제너레이터는 yield 에 지정된 값이 반환되고,
이터레이터에서 raise 으로 직접 StopIteration 예외를 발생시켰지만, 제너레이터는 알아서 함수가 끝나면 예외가 발생한다.)

추가로 제너레이터 객체에서 __iter__ 를 호출하면 self, 제너레이터 객처 자신을 반환한다.
"""


def what_is_yield():
    yield '간'
    yield '다'
    yield '!'


g_object = what_is_yield()  # 제너레이터 객체를 반환해서 변수에 저장
print(next(g_object))       # next()로 제너레이터의 yield 를 실행, yield 는 값을 반환하고 실행도 양보
print(next(g_object))       # next()로 제너레이터의 다음 yield 를 실행, 두번째 값을 반환하고 실행 양보
print(next(g_object))       # next()로 제너레이터의 마지막 yield 를 실행, 두번째 값을 반환하고 실행 양보
""" yield:
근데 왜 키워드 이름이 generate(제너레이트) 같은게 아니고 yield 일까? 이유는 yield 의 뜻이 생산하다, 양보하다 이기 때문이다.
이 뜻처럼 yield 를 사용하면 실제로 값을 함수 바깥으로 전달하고, 코드 실행도 함수 바깥으로 양보한다.

return 같지만 return 처럼 값을 반환하면서 함수를 종료하는 것이 아니라, 실행을 함수 바깥으로 '양보'하는 것이다.
(return 은 반환 즉시 함수가 끝나지만, yield 는 잠시 함수 바깥으로 코드가 실행되게 yield 뒤의 값을 반환하고 대기한다.)


참고로 제너레이터에서 함수 끝에 도착하거나 하면 함수가 종료되면서 StopIteration 예외가 발생했는데, return 함수로도
함수 중간에서든 return 으로 함수를 종료하면서 StopIteration 예외를 발생시킬 수 있다.
이때 return 에 반환값을 지정해서, StopIteration 예외가 발생할 때의 에러메시지를 반환할 수 있다.
"""
